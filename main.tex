\documentclass[a4paper,12pt]{report}
\usepackage{config}

% Description
\newcommand{\authorName}{GRAMA Alina}
\newcommand{\thesisTitle}{Разработка web API на C\#}  % на румынском?
\newcommand{\thesisTitleEng}{Developing a web API in C\#}
\newcommand{\uniGroupName}{DJ2203}
\newcommand{\thesisType}{licență}
\newcommand{\programulDeStudii}{licență}
\newcommand{\identificatorulCursului}{0211.7 Designul jocurilor}

\renewcommand{\year}{2025}
\newcommand{\location}{Chișinău}
\newcommand{\conferencesList}{Conferința Studențească, Editia XXVIII-a, \year}
\newcommand{\conducatorNume}{Curmanschii}
\newcommand{\conducatorPrenume}{Anton}
\newcommand{\github}{\url{                           }}
\newcommand{\chapterCount}{3}

\begin{document}

\input{foaie_de_titlu}

\clearpage
\tableofcontents

\clearpage
\unnumberedChapter{Список аббревиатур}
\begin{acronym}[JPEG]
    \acro{API}{Application Programming Interface}
    \acro{REST}{Representational State Transfer}
    \acro{DI}{Dependency Injection}
    \acro{ООП}{Объектно-Ориентированное Программирование}
    \acro{EF}{Entity Framework}
    \acro{HTTP}{HyperText Transfer Protocol}
    \acro{CRUD}{Create Read Update Delete}
    \acro{СУБД}{Система Управления Базами Данных}
    \acro{URL}{Uniform Resource Locator}
    \acro{MVC}{Model View Controller}
    \acro{SQL}{Structured Query Language}
    \acro{ORM}{Object-Relational Mapping}
    \acro{}{}
    \acro{}{}
\end{acronym}


% I think this one's required to be capitalized.
\unnumberedChapter{ВВЕДЕНИЕ}

\markpage{usefulStuffBegin}

\textbf{Актуальность и важность темы.}

Механизм веб-\acs{API} широко используется для различных приложений, таких как веб-приложения, мобильные приложения, 
облачные сервисы и интеграция с внешними системами. Данный API позволяет клиенту и серверу взаимодействовать друг с другом, 
обеспечивая надежный обмен данными. Использование ASP.NET Core предоставляет средства для разработки RESTful API, 
который является стандартом в установлении взаимодействия между клиентом и сервером.

Исходя из этого, изучение веб-\acs{API} является нужным для работы с базами данных для создания современных приложений.

\textbf{Цель и задачи.}

Целью дианной работы является демонстрация возможностей ASP.NET Core как современного фреймворка для разработки веб-\acs{API}. 
В рамках исследования и практической реализации будут продемонстрированы основные преимущества ASP.NET Core, включая его 
высокую производительность, модульность и гибкость в создании \acs{REST}ful \acs{API}. Для этого было решено создать приложение для 
продажи товаров, которое представит возможности веб-\acs{API} созданные на языке C\#.

\textbf{Методологическое и технологическое обеспечение.}

Разработка веб-\acs{API} включает использование принципов \acs{ООП} для структурирования кода, повышения его гибкости и читаемости. 
Основой создания приложения является \ac{REST}, обеспечивающий стандартизированный подход к построению \acs{API} через использование 
\acs{HTTP}-методов, статусных кодов и \acs{URL}-адресов. Для документирования и упрощения тестирования применяется Swagger, что позволяет 
визуализировать и описывать \acs{API}. Языком программирования является C\#, в качестве фреймворка используется ASP.NET Core.

\textbf{Научная новизна/оригинальность темы.}

Разработка веб-\acs{API} на C\# является актуальной областью исследований, поскольку современные веб-приложения требуют гибких, 
масштабируемых и безопасных способов взаимодействия между клиентами и серверами. В рамках данной работы изучаются
и применяются современные подходы к созданию веб-\acs{API}, такие как использование архитектурного стиля \acs{REST}, внедрение паттернов 
проектирования, а также применение различных подходов к проектированию базы данных.

\textbf{Прикладная значимость.}

Разработка веб-сервисов является неотъемлемой частью многих современных IT-проектов, и знание принципов построения высокоэффективных 
API открывает широкие возможности для работы в таких областях, как разработка веб-приложений, мобильных приложений, 
а также в сфере интеграции различных сервисов и систем.

Основная цель работы состоит в получении практических знаний и умений, которые будут востребованы в будущей профессиональной деятельности. 
Создание функционального веб-\acs{API} на C\# является не только учебной задачей, но и полезным продуктом, который можно применить в реальных проектах, 
что делает его ценным опытом для работы в разработке веб-\acs{API} приложений.

\textbf{Краткое описание глав.}



\chapter{Теоретические основы веб-\acs{API} и ASP.NET Core}\label{intro_chapter_title}

\section{Мотивация создания приложения}

Мотивацией написания данного приложения является не только образовательная цель, но также, идея для собственного проекта, который
имеет потенциал для реального применения. Масштаб и сложность данного проекта вызывают сомнения относительно возможности завершения проекта в сроки 
дипломной работы. Такой проект требует более объемной работы, возможно, участия команды, что в рамках текущих условий и сроков может оказаться 
сложным для самостоятельной реализации. Поэтому, было решено сделать более простой проект, который принесет значительный вклад в развитие знаний и навыков 
в области веб-разработки.

\section{Понятие и назначение веб-\acs{API}}

\subsection{Введение}

Веб-\acs{API}, который означает “интерфейс прикладного программирования” для клиента и сервера, 
является набором правил и протоколов, позволяющий различным приложениям понимать и взаимодействовать 
друг с другом. Они предоставляют возможность веб-приложениям общаться друг с другом с помощью баз данных, 
обеспечивая своевременную передачу данных. веб-\acs{API} работают на основе модели запрос-ответ, где клиент 
отправляет \acs{HTTP}-запрос  на сервер, а сервер обрабатывает запрос и отправляет ответ клиенту.

\subsection{Определение веб-\acs{API} и их виды}

Фреймворк ASP.NET Core поддерживает два подхода для создания веб-\acs{API}: \acs{API}, основанные на контроллерах 
и минимальные \acs{API}. Контроллеры - классы, производные от класса ControllerBase, которые определяют методы 
для каждого \acs{HTTP} метода, а минимальные \acs{API} основываются на создании \acs{API} с минимальным количеством 
зависимостей и использовании методов \texttt{app.MapGet}, \texttt{app.MapPost}, \texttt{app.MapPut} и \texttt{app.MapDelete}.\cite{controller_vs_minimal_api}

\subsection{Основные архитектурные стили веб-\acs{API}: \acs{REST}}

\ac{REST} - архитектурный стиль для создания систем, которые описывают принципы 
взаимодействия между клиентом и сервером. Основная цель \acs{REST} - создать простые и масштабируемые веб-сервисы. 
Данный архитектурный стиль используется для взаимодействия между клиентом и сервером через стандартные \acs{HTTP}-запросы.

Основные принципы \acs{REST}:
\begin{itemize}
    \item
        \textbf{Клиент-сервер}: клиент отвечает за взаимодействие с пользователем, сервер - за обработку запросов и управление данными.
    \item 
        \textbf{Отсутствие состояния (Stateless)}: каждый запрос клиента к серверу должен содержать всю информацию, необходимую для его обработки, 
        сервер не должен хранить состояние между запросами.
    \item
        \textbf{Кэшируемость (Cacheable)}: кэширование способствует предотвращению повторных запросов на сервер.
    \item
        \textbf{Единообразие интерфейса (Uniform Interface)}: все взаимодействия с API осуществляются с помощью единого стандартизированного интерфейса.
    \item
        \textbf{Код по запросу (Code on Demand)}: позволяет серверу расширять или настраивать функциональность клиента путем передачи исполняемого кода.
\end{itemize}

В \acs{REST}ful \acs{API} есть 4 \acs{HTTP}-метода, которые, также, являются операциями \acs{CRUD}: GET, POST, PUT, DELETE.

\section{ASP.NET Core как платформа для разработки веб-\acs{API}}

\subsection{История и эволюция}
ASP.NET Core - это кроссплатформенный, высокопроизводительный и модульный фреймворк для разработки веб-приложений и \acs{API}, созданный Microsoft. 
Он является преемником ASP.NET и представляет собой трансформацию архитектуры веб-разработки на платформе .NET.

В 2016 году Microsoft представила ASP.NET Core 1.0 - полностью переработанную версию ASP.NET, созданную для работы на Windows, Linux и macOS.\cite{announcing_asp_net_core_1_0}

В 2017 году вышел ASP.NET Core 2.0, который упростил разработку и добавил улучшенную работу с Entity Framework Core.\cite{announcing_asp_net_core_2_0}

В 2019 году Microsoft выпустила ASP.NET Core 3.0, который отказался от поддержки .NET Framework, полностью перейдя на .NET Core, 
а также, улучшилась работа с веб-\acs{API}, появилась возможность создавать веб-\acs{API} без необходимости в \acs{MVC}.\cite{announcing_asp_net_core_3_0}

В 2020-2021 - объединение .NET Framework и .NET Core в единую платформу .NET 5, а также были представлены минимальные \acs{API} в .NET 6.\cite{announcing_dot_net_5_0}\cite{announcing_dot_net_6_0}

В 2022 в .NET 7 появилась улучшенная работа с веб-\acs{API} и минимальными \acs{API}.\cite{announcing_dot_net_7_0}

В 2023-2024 в .NET 8-9 - улучшения фреймворка.\cite{announcing_dot_net_8_0}\cite{announcing_dot_net_9_0}

\subsection{Основные преимущества}

ASP.NET Core сочетает в себе производительность, гибкость и современный подход к веб-разработке, что делает его отличным выбором 
для создания масштабируемых и надежных веб-приложений.

Преимущества выбора ASP.NET Core:
\begin{itemize}
    \item
        \textbf{Кроссплатформенность} - работает на Windows, Linux и macOS, что позволяет разрабатывать и развертывать приложения на разных операционных системах.
    \item 
        \textbf{Модульность и гибкость} - поддерживает как контроллеры (\acs{MVC},), так и минимальные \acs{API}, а также Razor Pages, Blazor, что позволяет выбрать 
        подходящую архитектуру для проекта.
    \item
        \textbf{Встроенный механизм зависимостей (Dependency Injection)} - \acs{DI} позволяет легко управлять зависимостями и создавать тестируемые, расширяемые приложения.
    \item
        \textbf{Современные технологии веб-разработки} - интеграция с \acs{EF} Core для работы с базами данных.
    \item
        \textbf{Большая поддержка сообщества и официальная документация от Microsoft} - регулярные обновления, обширная документация и большое сообщество 
        разработчиков делают ASP.NET Core надежным и актуальным фреймворком.
\end{itemize}

Данная технология была выбрана, так как она является по факту стандартом в написании веб-\acs{API} приложений.

\section{Object-Relational Mapping и Entity Framework Core}

\subsection{Определение \acs{ORM} и \acs{EF} Core}

\acs{ORM} - технология, которая позволяет работать с базами данных с использованием \acs{ООП} вместо написания \acs{SQL}-запросов. 
Данная технология является посредником между языком программирования и базой данных. 
При ее помощи можно получать данные из базы данных и работать с ними как с объектами, 
а также, записывать объекты из программы в базу данных.\cite{orm}

Преимущества \acs{ORM}:
\begin{itemize}
    \item
        Выполнение \acs{CRUD} операций без использования \acs{SQL} вручную.
    \item
        Представление данных из базы данных как объектов, с которыми может работать язык программирования.
    \item
        Безошибочное сопоставление полей из базы данных и свойств полученных объектов друг с другом.
\end{itemize}

\textbf{Entity Framework Core} - \acs{ORM} фреймворк, который позволяет сопоставлять C\# классы с таблицами базы данных, 
то есть данная технология позволяет взаимодействовать с базой данных через C\# код, а не напрямую через \acs{SQL}-запросы.\cite{ef_core}


\subsection{Класс DbContext}

\acs{EF} Core использует класс \texttt{DbContext}, который является неотъемлемой частью \acs{EF}, позволяющий запрашивать и сохранять данные. 

\texttt{DbContext} предоставляет следующие возможности:
\begin{itemize}
    \item
        Управление подключением к базе данных через строку подключения.
    \item 
        Написание и выполнение запросов.
    \item
        Сохранение и отслеживание изменений данных в базе данных.
\end{itemize}

\subsection{Основные преимущества \acs{EF} Core}

\begin{enumerate}
    \item
        \acs{EF} Core предлагает встроенную систему миграций, которая позволяет легко 
        обновлять базу данных, добавлять новые таблицы, обновлять схемы.
    \item
        \acs{EF} Core поддерживает сортировку и фильтрацию данных, 
        что является необходимым при работе с большими объемами информации, эти функции позволяют оптимизировать производительность 
        запросов и делать их более быстрыми и эффективными.
    \item
        Вместо написания \acs{SQL}-запросов можно работать с объектами и классами, 
        что делает код более понятным и удобным в поддержке.
    \item
        \acs{EF} Core поддерживает широкий спектр баз данных.
\end{enumerate}

\section{Dependency Injection в ASP.NET Core}

\subsection{Понятие и принцип работы \acs{DI}}

ASP.NET Core поддерживает Dependency Injection, который представляет собой метод достижения инверсии управления 
между классами и их зависимостями. Зависимость - объект, от которого зависит другой объект.

Dependency Injection - процесс, в котором внедряется зависимый объект класса в класс, который зависит от этого объекта.
А также, позволяет разрабатывать слабосвязанный код. 

Это делается для того, чтобы класс не зависел от конкретной реализации своей зависимости, 
а лишь от интерфейса или абстракции. Зависимости передаются объекту через конструктор, свойство или метод, а не создаются внутри объекта. 
Вместо того чтобы создавать зависимости внутри класса, \acs{DI} позволяет передать, то есть внедрить эти зависимости извне.\cite{dependency_injection}

\subsection{Виды внедрения зависимостей}

Существуют 3 вида внедрения зависимостей. Данные виды отличаются между собой тем, как именно они передаются объекту.

Первый вид, внедрение через \textbf{конструктор}, где зависимости явно передаются в качестве параметров конструктору клиентского класса во время создания объекта.

Второй вид, внедрение через \textbf{свойство}, где методы сеттера отвечают за установку и изменение значения приватной переменной экземпляра.

Третий вид, внедрение через \textbf{метод}, где зависимость передается в класс через параметры метода.

\subsection{Жизненный цикл зависимостей и их различия}

Жизненный цикл зависимостей - как долго объект существует в рамках приложения. 

Существуют 3 вида жизненных циклов зависимостей:
\begin{itemize}
    \item
        \textbf{Transient}: при каждом обращении к сервису создается новый объект сервиса, это означает, что каждый раз, 
        когда приложение или класс требует зависимость, контейнер создает новый экземпляр объекта.
    \item
        \textbf{Scoped}: объекты создаются один раз на каждый запрос в приложении, это предполагает, 
        что сохраняется состояние объекта в течение одного запроса, но не на всю жизнь приложения.
    \item
        \textbf{Singleton}:  объекты создаются один раз на всю жизнь приложения, это означает, 
        что создается один экземпляр класса и он используется для всех запросов в процессе работы приложения. 
\end{itemize}

\chapterConclusionSection{intro_chapter_title}

В данной главе были описаны основные понятия и принципы, которые лежат в основе разработки веб-\acs{API} в ASP.NET Core. 
В рамках фреймворка ASP.NET Core можно использовать два подхода для создания веб-\acs{API}: \acs{API} на основе контроллеров и минимальные \acs{API}, 
каждый из которых применим в зависимости от размера и сложности проекта.

Также, были описаны неотъемлемые элементы веб-\acs{API} проектов, такие как архитектурный стиль \acs{REST}, \acs{ORM} фреймворк Entity Framework Core, 
механизм Dependency Injection.

Владение этими знаниями позволяет создать основу для проектирования и программирования веб-\acs{API} приложения.

\chapter{Проектирование архитектуры системы}\label{architecture_chapter_title}

\section{Архитектурное проектирование системы}

\subsection{Монолитная и микросервисная архитектуры}

В разработке веб-приложений существует два основных подхода к построению архитектуры:
\begin{enumerate}
    \item
        \textbf{Монолитная архитектура} -- архитектура, при которой вся система разрабатывается как единое приложение, 
        а также, расширение и обновление системы требуют изменение всей системы.
    \item
        \textbf{Микросервисная архитектура} -- архитектура, при которой система разбивается на отдельные сервисы, 
        каждый из которого отвечает за свою часть функционала, при этом изменения в отдельных частях приложения не влияют на весь проект.\cite{application_architecture}
\end{enumerate}

Так как в ходе разработки проекта получится небольшое веб-приложение, то монолитная архитектура является более подходящей.

\subsection{Modular Monolith}

Modular Monolith -- монолитное приложение, разделённое на логические модули, каждое из которых инкапсулирует свою область ответственности.
Это архитектурный подход, сочетающий в себе аспекты как монолитной, так и модульной парадигм проектирования.\cite{modular_monolith}

\textbf{Характеристики модульного монолита:}
\begin{itemize}
    \item
        Модульность: независимые части приложения с собственными границами ответственности.
    \item 
        Общая кодовая база и данные: единые библиотеки, схемы баз данных и миграции упрощают разработку.
    \item
        Модульные монолиты обеспечивают преимущества масштабируемости и удобства обслуживания по сравнению 
        с традиционными монолитными архитектурами. Разбивая приложение на модули дает возможность более 
        эффективно управлять сложностью и масштабировать отдельные компоненты независимо.
\end{itemize}

\textbf{Основные принципы проектирования Modular Monolith:}
\begin{itemize}
    \item
        Вертикальное разделение -- каждая фича имеет свой модуль: контроллеры, сервисы, репозитории, схемы миграций.
    \item
        Чёткие контракты -- модуль общается только через интерфейсы и DTO.
    \item
        Dependency Inversion -- зависимости направлены внутрь: высокоуровневые модули не зависят от низкоуровневых реализаций.
    \item
        Принцип единой ответственности: каждый модуль имеет лишь одну зону изменений.
\end{itemize}

\subsection{Разделение системы на уровни}

Многоуровневая система -- паттерн проектирования, который разбивает приложение на отдельные уровни, каждый из которых отвечает 
за свою функциональность. Каждый уровень многоуровневой системы не должен быть тесно связан с другими слоями системы. Каждый слой 
выполняет только свою роль и взаимодействует с другими слоями через четко определенные интерфейсы.

Обычно данные уровни включают в себя 4 уровня: уровень представления, уровень бизнес-логики, уровень доступа к данным и 
уровень сущностей:
\begin{enumerate}
    \item
        \textbf{Уровень представления (Presentation Layer)} -- уровень взаимодействия пользователя с приложением, 
        который не должен содержать бизнес-логику и должен быть независимым от логики обработки данных, 
        чтобы можно было легко изменять интерфейс, не затрагивая другие части системы.
    \item
        \textbf{Уровень бизнес-логики (Business Logic Layer)} -- уровень наборов правил и операций, которые определяют,
        как данные обрабатываются внутри системы.
    \item
        \textbf{Уровень доступа к данным (Data Access Layer)} -- уровень взаимодействия с базой данной, 
        в котором хранятся запросы к базе, а также логика сохранения и извлечения данных.
    \item
        \textbf{Уровень сущностей (Entity Layer)} -- уровень опредяющий основные сущности, которые отражают концепии реального 
        мира, эти сущности обычно соответствуют таблицам базы данных, но они не должны содержать бизнес-логику.
\end{enumerate}

\textbf{Преимущества многоуровневой архитектуры:}
\begin{itemize}
    \item
        \textbf{Масштабируемость:} Каждое изменение в одном слое минимально затрагивает другие слои системы.
    \item
        \textbf{Тестируемость:} Каждый слой можно тестировать отдельно, что упрощает написание юнит-тестов и поддержку системы.
    \item
        \textbf{Гибкость:} Многоуровневая архитектура позволяет легко адаптировать систему под изменения, такие как добавление новых функций или улучшение производительности системы.
\end{itemize}

\textbf{Недостатки многоуровневой архитектуры:}
\begin{itemize}
    \item
        При необходимости добавлении новго функционала, нужно изменять каждый слой системы.
    \item
        Не всегда понятно в какой именно слой нужно добавить новые функции или внести изменения.
    \item
        Наличие большого количества избыточных абстракций, не выполняющих функционально значимых операций, 
        но требующих постоянного преобразования объектов и ответов при взаимодействии между уровнями системы.\cite{design_patterns_architecture}
\end{itemize}
 

\section{Подходы к проектированию базы данных}

\subsection{Code-First и Database-First}

В C\# с использованием Entity Framework Core существует два основных подхода к работе с базами данных:
\begin{itemize}
    \item
        \textbf{Code-First} -- сначала создается код, то есть модели, а затем на его основе формируется база данных.

        \textbf{Преимущества Code-First:}
        \begin{enumerate}
                    \item
                        Полный контроль над архитектурой и логикой модели данных.
                    \item
                        Удобно для новых проектов, где структура база данных ещё не определена.
                    \item
                        Лёгкое управление изменениями с помощью миграций.
        \end{enumerate}
    \item
        \textbf{Database-First} -- сначала создается база данных, затем на ее основе автоматически генерируются модели.

        \textbf{Преимущества Database-First:}
        \begin{enumerate}
                    \item
                        Удобен при работе с уже существующими базами данных.
                    \item
                        Быстрая генерация моделей из готовой схемы.
                    \item
                        Поддержка больших legacy-баз.
        \end{enumerate}
\end{itemize}

\subsection{Обоснование выбора подхода для текущего проекта}

Для данной работы был выбран подход Code-First, так как база данных создается с нуля, все изменения можно контролировать через код и миграции,
а также, связи между сущностями создаются автоматически.

\section{Проектирование структуры базы данных}

\subsection{Разработка ER-диаграммы базы данных}

\subsection{Описание ключевых сущностей и их атрибутов}

В рамках проектирования базы данных были определены основные сущности, необходимые для функционирования веб-приложения магазина такие как: товар и заказ.

Сущность Product представляет собой товар, доступный в магазине. Он содержит основную информацию, необходимую для отображения и управления товаром в системе.

\textbf{Атрибуты сущности Товар:}
\begin{enumerate}
    \item
        Id (int) -- уникальный идентификатор товара.
    \item
        Name (string) -- название модели товара.
    \item
        Brand (string) -- название производителя товара.
    \item
        Price (decimal) -- цена товара.
\end{enumerate}

\begin{minted}{csharp}
    public class Product
    {
        public int Id { get; set; } 
        public string? Name { get; set; }
        public string? Brand { get; set; }  
    
        [Column(TypeName = "decimal(18,2)")]  
        public decimal Price { get; set; }  
    }
\end{minted}

Сущность Order представляет собой заказ, который содержит информацию о списке товаров.

\textbf{Атрибуты сущности Заказ:}
\begin{enumerate}
    \item
        Id (int) -- уникальный идентификатор заказа.
    \item
        DateTime (DateTime) -- время создания заказа.
    \item
        Status (OrderStatus) -- состояние, в котором находится товар.
    \item
        Items (List<OrderItem>) -- id и количество товара.
    \item
        TotalPrice (decimal) -- общая стоимость товаров.
    \item
        PaymentMethod (PaymentMethod) -- метод оплаты товаров.
\end{enumerate}

\begin{minted}{csharp}
    public class Order
{
    public int Id { get; set; }
    public DateTime DateTime { get; set; }
    public OrderStatus Status { get; set; }
    public List<OrderItem> Items { get; set; } = new List<OrderItem>();
    public decimal TotalPrice { get; set; }
    public PaymentMethod PaymentMethod { get; set; }
}
\end{minted}

\begin{minted}{csharp}
    public class OrderItem
{
    public int Id { get; set; }
    public int ProductId { get; set; }
    public int Quantity { get; set; }
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
}
\end{minted}

\section{Ключи в базах данных}

Ключи -- способ идентификации строк в таблице.

Ключи обеспечивают однозначную идентификацию записей и поддерживают целостность данных. 
Без них база превратилась бы в беспорядок, и поиск, обновление или удаление нужной 
информации стало бы практически невозможным.

В СУБД существуют 8 различных типов ключей: супер ключ, первичный ключ, ключ-кандидат
альтернативный ключ, внешний ключ, составной ключ, композитный ключ и суррогатный ключ.

\subsection{Типы ключей}

\textbf{Супер ключ} -- набор одного или нескольких столбцов таблицы, значения которых в совокупности однозначно идентифицируют каждую запись.

\textbf{Ключ-кандидат} -- минимальный, а именно, незаменимый суперключ, то есть суперключ, из которого нельзя убрать ни одного столбца без потери свойства уникальности.

\textbf{Первичный ключ} -- выбранный из кандидатных ключей главный ключ таблицы, на который по умолчанию опираются ссылки и индексы.

\textbf{Альтернативный ключ} -- любой кандидатный ключ, который не был выбран в качестве первичного.

\textbf{Составной ключ} -- ключ, который состоит из двух и более столбцов, значение комбинации которых уникально.

\textbf{Внешний ключ} -- атрибут или набор атрибутов в одной таблице, ссылающиеся на первичный (или кандидантный) ключ другой таблицы.

\textbf{Суррогатный ключ} -- искусственный ключ, предназначенный для уникальной идентификации каждой записи.

\textbf{Композитный ключ} -- комбинация двух или более столбцов, которые однозначно идентифицируют строки в таблице.

\textbf{Необходимость разных типов ключей}
\begin{itemize}
    \item
        Ключи помогают идентифицировать любую строку данных в таблице. 
    \item
        Позволяют установить и определить связь между таблицами.
    \item
        Помогают обеспечить идентичность и целостность в отношениях.
\end{itemize}

\section{Связи между сущностями}

\subsection{Введение}

Связь между таблицами строится с помощью внешних ключей -- это столбец или несколько столбцов в одной таблице, 
где хранятся значения первичного ключа другой таблицы. Так база данных понимает, какие записи связаны между собой, 
и не позволяет нарушить эту связь.

\textbf{Типы связей}
\begin{enumerate}
    \item
        Многие ко многим.
    \item
        Один к многим.
    \item
        Один к одному.
\end{enumerate}

\subsection{Многие ко многим}

В модели "многие ко многим" каждая запись таблицы A может быть связана сразу с несколькими записями таблицы B, 
и одновременно любая запись таблицы B может иметь ссылки на множество записей таблицы A.

\subsection{Один ко многим}

В типе связей "один ко многим" несколько строк из дочерний таблицы зависят от одной строки в родительской таблице.
Данный тип связи поддерживается через внешние ключи в дочерней таблице, значение которых должно либо совпадать 
с существующим первичным ключом родителя, либо быть NULL.

\subsection{Один к одному}

В данном типе связей объекту одной сущности можно сопоставить только один объект другой сущности.
Этот тип связей предполагает разбиение одной большой таблицы на несколько маленьких. 
Основная родительская таблица в этом случае продолжает содержать часто используемые данные, 
а дочерняя зависимая таблица обычно хранит данные, которые используются реже.

\section{Бизнес-логика приложения}

\subsection{Введение}

Бизнес-логика представляет собой совокупность правил и условий, управляющих поведением объектов, сущностей, классов и данных внутри приложения.

Приложение служит платформой простого магазина, позволяя:
\begin{itemize}
    \item
        Вести каталог товаров.
    \item
        Оформлять заказы, учитывать их состояние и способы оплаты.
    \item
        Гарантировать целостность данных и корректность расчётов.
\end{itemize}

\subsection{Управление каталогом  товаров}

\begin{itemize}
    \item
        Добавление -- при POST-запросе создаётся запись Product.
    \item 
        Просмотр -- GET-запросы возвращают список или единичный товар.
    \item   
        Редактирование -- PUT изменяет только значимые атрибуты (Name, Brand, Price).
    \item
        Удаление -- DELETE убирает товар из каталога, если на него нет активных заказов.
\end{itemize}

\subsection{}

\subsection{}

\chapterConclusionSection{architecture_chapter_title}

В данной главе была заложена теоретическая основа архитектуры системы, которую следует реализовать. 
Была определена структура приложения как модульного монолита с чётким разделением на уровни: 
Presentation, Business Logic, Data Access и Entity, что обеспечивает масштабируемость и тестируемость системы.
Этот теоретический фундамент создаёт основу для практической реализации, оставаясь при этом гибким: 
детали внутренней логики валидации, обработки заказов и интеграций будут дорабатываться на последующих этапах.

\chapter{Реализация системы}\label{implementation_chapter_title}

\section{Introducere în capitol}


%În continuare, se va prezenta implementarea unui decodor \ac{PNG} care va fi folosit pentru
%a vizualiza formatul \ac{PNG} printr-o aplicație \ac{GUI}.
%Decodorul va fi implementat în limbajul de programare Zig\cite{zig}
%după specificația \ac{PNG}, versiunea 1.2\cite{png_spec}.
%Interfața grafică va fi implementată folosind Raylib\cite{raylib}, tot în Zig.

Vor fi explicate cât modulele principale ce țin direct de formatul PNG,
atât și modulele de bază care au facilitat dezvoltarea întregului sistem.




\unnumberedChapter{Окончательные выводы и рекомендации}

În această lucrare a fost discutată importanța cunoașterii formatului \ac{PNG}.
În urma studierii formatului a devenit clar că \ac{PNG} nu este pur și simplu un format de imagine,
dar este proiectat în așa fel ca să permită extinderea, folosirea liberă și
capacitățile neaccesibile în trecut în alte formaturi.

Formatul de comprimare Zlib folosit în \ac{PNG},
cu toate că nu este însuși folosit pe scară largă în aplicații,
folosește subformatul DEFLATE care este o parte esențială a mai multor alți algoritmi.
DEFLATE folosește arbori Huffman care pot fi utili pentru orice aplicație
unde este necesar un mod de codificare eficient.

A fost discutat procesul de dezvoltare a unei aplicații ce ține de folosirea unui arbore sintactic
pentru a putea vizualiza grafic date despre \ac{PNG}.
Utilizarea unui arbore a fost argumentată, iar implementarea imbunătățită în mod gradual și discutată pe larg.
Au fost discutate modulele intermediare \texttt{pipelines} și modulul parserului care
se folosesc pentru a realiza derivarea arborelui sintactic.

Toate codurile sursă, inclusiv codurile de program și textul lucrării
în forma înainte de randare, pot fi accesate pe GitHub după următorul link: \github.

%Rezultatele obținute au fost raportate la \textbf{\conferencesList}\cite{self}.

\newpage
\markpage{usefulStuffEnd}


% Bibliography
\bibliographystyle{plain}
\bibliography{bibliography}
\addcontentsline{toc}{chapter}{\bibname}

% Appendices
\appendix

\unnumberedChapter{Anexe}

\section{Funcția actualizării valorii CRC}\label{appendix:crc} %407


\section{Iteratorul segmentelor unei secvențe}\label{appendix:sequence_iterator} %1044


\section{Calculul CRC în parser}\label{appendix:crc_sequence_defer_example} %1077



\section{TaggedArrayList.zig}\label{appendix:main__TaggedArrayList} %1678

\section{Codul cheie arborelui Huffman}\label{appendix:huffman_tree}%1792



\section{Afișarea editorului hex}\label{appendix:draw_hex_grid}%2062


\section{Căutarea drumului de noduri în arbore}\label{appendix:node_path_search_impl}%2086


\section{Drag-and-drop}\label{appendix:drag_and_drop}%2106


% \section{common.zig}\label{appendix:main__parser_png_common}
% \inputminted{zig}{../src/parser/png/common.zig}

% \section{chunks.zig}\label{appendix:main__parser_png_chunks}
% \inputminted{zig}{../src/parser/png/chunks.zig}

% \section{parser.zig}\label{appendix:main__parser_png_parser}
% \inputminted{zig}{../src/parser/png/parser.zig}

% \section{utils.zig}\label{appendix:main__parser_png_utils}
% \inputminted{zig}{../src/parser/png/utils.zig}

% \section{zlib.zig}\label{appendix:main__parser_zlib_zlib}
% \inputminted{zig}{../src/parser/zlib/zlib.zig}

% \section{helper.zig}\label{appendix:main__parser_zlib_helper}
% \inputminted{zig}{../src/parser/zlib/helper.zig}

% \section{deflate.zig}\label{appendix:main__parser_zlib_deflate}
% \inputminted{zig}{../src/parser/zlib/deflate.zig}

% \section{huffmanTree.zig}\label{appendix:main__parser_zlib_huffmanTree}
% \inputminted{zig}{../src/parser/zlib/huffmanTree.zig}

% \section{noCompression.zig}\label{appendix:main__parser_zlib_noCompression}
% \inputminted{zig}{../src/parser/zlib/noCompression.zig}

% \section{dynamic.zig}\label{appendix:main__parser_zlib_dynamic}
% \inputminted{zig}{../src/parser/zlib/dynamic.zig}

% \section{fixed.zig}\label{appendix:main__parser_zlib_fixed}
% \inputminted{zig}{../src/parser/zlib/fixed.zig}

% \section{ast.zig}\label{appendix:main__parser_shared_ast}
% \inputminted{zig}{../src/parser/shared/ast.zig}

% \section{Settings.zig}\label{appendix:main__parser_shared_Settings}
% \inputminted{zig}{../src/parser/shared/Settings.zig}

% \section{level.zig}\label{appendix:main__parser_shared_level}
% \inputminted{zig}{../src/parser/shared/level.zig}

% \section{NodeOperations.zig}\label{appendix:main__parser_shared_NodeOperations}
% \inputminted{zig}{../src/parser/shared/NodeOperations.zig}

% \section{CommonContext.zig}\label{appendix:main__parser_shared_CommonContext}
% \inputminted{zig}{../src/parser/shared/CommonContext.zig}

% \section{pngDebug.zig}\label{appendix:main__pngDebug}
% \inputminted{zig}{../src/pngDebug.zig}

\end{document}
% vim: fdm=syntax
